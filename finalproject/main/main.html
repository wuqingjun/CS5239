<!doctype html>
<html lang="en">
	<head>
		<title>Frozen</title>
		<link rel="stylesheet" type="text/css" href="style.css" />
        <script type="text/javascript" src="libs/three.js"></script>
	    <script type="text/javascript" src="libs/dat.gui.min.js"></script>
        <script type="text/javascript" src="OBJLoader.js"></script>
	</head>
	<body>
		<script type="x-shader/x-vertex" id="main_vs">
			uniform float radiusX;
			uniform float radiusZ;
			uniform float size;
			uniform float scale;
			uniform float height;
			uniform float elapsedTime;
			uniform float speedH;
			uniform float speedV;

			void main() {
				vec3 pos = position;
				pos.x += cos((elapsedTime + position.z) * 0.25 * speedH) * radiusX;
				pos.y = mod(pos.y - elapsedTime * speedV, height);
				pos.z += sin((elapsedTime + position.x) * 0.25 * speedH) * radiusZ;

				vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );

				gl_PointSize = size * ( scale / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

	<script type="x-shader/x-fragment" id="main_fs">
			uniform vec3 color;
			uniform float opacity;
			uniform sampler2D texture;

			void main() {
				vec4 texColor = texture2D( texture, gl_PointCoord );
				gl_FragColor = texColor * vec4( color, opacity );
			}
		</script>

        <script id="fragmentShader" type="x-shader/x-fragment">

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vReflect;
            varying float ao;
            uniform sampler2D tShine;
            uniform float time;

            float PI = 3.14159265358979323846264;

            void main() {

            float yaw = .5 - atan( vReflect.z, - vReflect.x ) / ( 2.0 * PI );
            float pitch = .5 - asin( vReflect.y ) / PI;
            vec2 pos = vec2( yaw, pitch );
            vec3 color = texture2D( tShine, pos ).rgb;

            float diffuse_value1 = .0015 * max(dot(vNormal, vec3( -490.0, 29.8, -85.8 ) ), 0.0);
            float diffuse_value2 = .0005 * max(dot(vNormal, vec3( -460.0, 40.27, 187.4 ) ), 0.0);
            float diffuse_value3 = .0010 * max(dot(vNormal, vec3( 175.5, 30.04, 466.4 ) ), 0.0);
            float diffuse_value4 = .0005 * max(dot(vNormal, vec3( 466.0, 45.3, 172.9 ) ), 0.0);

            gl_FragColor = vec4( color - .15 * ao + .5 * vec3( diffuse_value1 + diffuse_value2 + diffuse_value3 + diffuse_value4 ), 1.0 );

            }


        </script>

        <script id="vertexShader" type="x-shader/x-vertex">

            vec3 mod289(vec3 x)
            {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289(vec4 x)
            {
                return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x)
            {
                return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r)
            {
                return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec3 fade(vec3 t) {
                return t*t*t*(t*(t*6.0-15.0)+10.0);
            }

            // Classic Perlin noise
            float cnoise(vec3 P)
            {
                vec3 Pi0 = floor(P); // Integer part for indexing
                vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return 2.2 * n_xyz;
            }

            // Classic Perlin noise, periodic variant
            float pnoise(vec3 P, vec3 rep)
            {
                vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
                vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                    return 2.2 * n_xyz;
                }

                float stripes( float x, float f) {
                    float PI = 3.14159265358979323846264;
                    float t = .5 + .5 * sin( f * 2.0 * PI * x);
                    return t * t - .5;
                }

                float turbulence( vec3 p ) {
                    float w = 100.0;
                    float t = -.5;
                    for (float f = 1.0 ; f <= 10.0 ; f++ ){
                        float power = pow( 2.0, f );
                        t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
                    }
                    return t;
                }

                float f( vec3 p ) {
                    return pnoise( vec3( p ), vec3( 10.0, 10.0, 10.0 ) );
                    return pnoise( 8.0 * vec3( p ), vec3( 10.0, 10.0, 10.0 ) );
                }

                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec3 vReflect;
                varying float ao;
                uniform float time;
                uniform float weight;

                float fround( float value ) {
                return floor( value + 0.5 );
                }

                vec3 v3round( vec3 value ) {
                return vec3( fround( value.x ), fround( value.y ), fround( value.z ) );
                }

                void main() {

                vec3 evNormal = normal;
                vec3 aniNormal = 5.0 * evNormal + time;
                float f0 = weight * f( aniNormal );
                float fx = weight * f( aniNormal + vec3( .0001, 0.0, 0.0 ) );
                float fy = weight * f( aniNormal + vec3( 0.0, .0001, 0.0 ) );
                float fz = weight * f( aniNormal + vec3( 0.0, 0.0, .0001 ) );
                vec3 modifiedNormal = normalize( evNormal - vec3( (fx - f0) / .0001, (fy - f0) / .0001, (fz - f0) / .0001 ) );

                if( weight > 0.0 ) {
                    ao = f0 / weight;
                } else {
                    ao = 0.0;
                }
                vNormal = modifiedNormal;
                vUv = uv;
                vec3 newPosition = position + f0 * evNormal;
                vec3 nWorld = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * modifiedNormal );
                vReflect = normalize( reflect( normalize( newPosition.xyz - cameraPosition ), nWorld ) );
                gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
            }



        </script>


	<script>
        window.onload = function () {
            var renderer,
                scene,
                camera,
                cameraRadius = 50.0,
                cameraTarget,
                cameraX = 0,
                cameraY = 0,
                cameraZ = cameraRadius,
                particleSystem,
                particleSystemHeight = 100.0,
                clock,
                controls,
                parameters,
                onParametersUpdate,
                textureSnow,
                textureElsa,
                textureOlaf,
                shaderMaterial,
                uniforms;
            var perWeight = 10.0;
            var torusGeo, torus;

            init();
            animate();


            function init() {

                renderer = new THREE.WebGLRenderer();

                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(new THREE.Color(0x000000));

                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.x = 35;
                camera.position.y = 108;
                camera.position.z = -114;
                cameraTarget = new THREE.Vector3(0, 0, 0);

                var ambient = new THREE.AmbientLight(0x101030);
                scene.add(ambient);

                var directionalLight = new THREE.DirectionalLight(0xffeedd);
                directionalLight.position.set(0, 0, 1);
                scene.add(directionalLight);

                textureSnow = THREE.ImageUtils.loadTexture('snowflake1.png');

                var numParticles = 10000,
                    width = 100,
                    height = particleSystemHeight,
                    depth = 100,
                    parameters = {
                        color: 0xFFFFFF,
                        height: particleSystemHeight,
                        radiusX: 2.5,
                        radiusZ: 2.5,
                        size: 100,
                        scale: 4.0,
                        opacity: 0.4,
                        speedH: 1.0,
                        speedV: 1.0,
                        cameraX: 35,
                        cameraY: 108,
                        cameraZ: -114
                    },
                    systemGeometry = new THREE.Geometry(),
                    systemMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            color: { type: 'c', value: new THREE.Color(parameters.color) },
                            height: { type: 'f', value: parameters.height },
                            elapsedTime: { type: 'f', value: 0 },
                            radiusX: { type: 'f', value: parameters.radiusX },
                            radiusZ: { type: 'f', value: parameters.radiusZ },
                            size: { type: 'f', value: parameters.size },
                            scale: { type: 'f', value: parameters.scale },
                            opacity: { type: 'f', value: parameters.opacity },
                            texture: { type: 't', value: textureSnow },
                            speedH: { type: 'f', value: parameters.speedH },
                            speedV: { type: 'f', value: parameters.speedV }
                        },
                        vertexShader: document.getElementById('main_vs').textContent,
                        fragmentShader: document.getElementById('main_fs').textContent,
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthTest: false
                    });

                for (var i = 0; i < numParticles; i++) {
                    var vertex = new THREE.Vector3(
                            rand(width),
                            Math.random() * height,
                            rand(depth)
                        );

                    systemGeometry.vertices.push(vertex);
                }

                particleSystem = new THREE.ParticleSystem(systemGeometry, systemMaterial);
                particleSystem.position.y = -height / 2;

                scene.add(particleSystem);


                // adding
                var manager = new THREE.LoadingManager();
                manager.onProgress = function (item, loaded, total) {

                    console.log(item, loaded, total);

                };

                textureElsa = new THREE.Texture();
              //  textureOlaf = new THREE.Texture();

                var onProgress = function (xhr) {
                    if (xhr.lengthComputable) {
                        var percentComplete = xhr.loaded / xhr.total * 100;
                        console.log(Math.round(percentComplete, 2) + '% downloaded');
                    }
                };

                var onError = function (xhr) {
                    console.log("error happening");
                };


                var imageLoader = new THREE.ImageLoader(manager);
                imageLoader.load('ObjectSurface_Color.png', function (image) {

                    textureElsa.image = image;
                    textureElsa.needsUpdate = true;

                });


                // model

                var loader = new THREE.OBJLoader(manager);
                loader.load('Elsa2.obj', function (object) {
                    object.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.material.map = textureElsa;
                        }
                    });

                    object.position.y = 0;
                    object.position.x = 0;
                    object.scale.set(10, 10, 10);
                    scene.add(object);

                }, onProgress, onError);

  
                // adding olaf:
                var img = new Image;
                img.src = "http://crossorigin.me/http://i.imgur.com/rmPw7Lr.jpg";
                // This makes it work
                img.crossOrigin = "Anonymous";
                THREE.ImageUtils.crossOrigin = '';
                //Shader Material Loader
                shaderMaterial = new THREE.ShaderMaterial({

                    uniforms: {
                        tShine: { type: "t", value: THREE.ImageUtils.loadTexture(img.src) },
                        time: { type: "f", value: 0 },
                        weight: { type: "f", value: 0 }
                    },


                    vertexShader: document.getElementById('vertexShader').textContent,
                    fragmentShader: document.getElementById('fragmentShader').textContent

                });

                shaderMaterial.uniforms.tShine.wrapS = THREE.Repeat;
                shaderMaterial.uniforms.tShine.wrapT = THREE.Repeat;  


                // torus

                //torus = new THREE.Mesh(torusGeo, shaderMaterial);
                //torus.doubleSided = true;
                //torus.position.set(0, 0, 0);
                //torus.rotateX(Math.PI / 2);
                //torus.rotateZ(Math.PI);
                //torus.scale.set(20, 20, 20);
                //scene.add(torus);


                var loader2 = new THREE.ObjectLoader();
                loader2.load("olaf.json", function (obj) {
                    //obj.scale.set(15,15,15);
                    obj.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                        if (child.geometry !== undefined) {
                            var t = new THREE.Mesh(child.geometry, shaderMaterial);
                            t.doubleSided = true;
                            t.position.set(0, 0, 0);
                            t.rotateX(Math.PI / 2);
                            t.rotateZ(Math.PI);
                            t.scale.set(10, 10, 10);
                            scene.add(t);
                        }
                    });
                }, onProgress, onError);


                clock = new THREE.Clock();

                document.body.appendChild(renderer.domElement);

                onParametersUpdate = function (v) {
                    systemMaterial.uniforms.color.value.set(parameters.color);
                    systemMaterial.uniforms.height.value = parameters.height;
                    systemMaterial.uniforms.radiusX.value = parameters.radiusX;
                    systemMaterial.uniforms.radiusZ.value = parameters.radiusZ;
                    systemMaterial.uniforms.size.value = parameters.size;
                    systemMaterial.uniforms.scale.value = parameters.scale;
                    systemMaterial.uniforms.opacity.value = parameters.opacity;
                    systemMaterial.uniforms.speedH.value = parameters.speedH;
                    systemMaterial.uniforms.speedV.value = parameters.speedV;
                    cameraX = parameters.cameraX;
                    cameraY = parameters.cameraY;
                    cameraZ = parameters.cameraZ;

                    //camera.position.x = parameters.cameraX;
                    //camera.position.y = parameters.cameraY;
                    //camera.position.z = parameters.cameraZ;
                    //renderer.render(scene, camera);
                }

                controls = new dat.GUI();
                controls.close();

                controls.addColor(parameters, 'color').onChange(onParametersUpdate);
                controls.add(parameters, 'height', 0, particleSystemHeight * 2.0).onChange(onParametersUpdate);
                controls.add(parameters, 'radiusX', 0, 10).onChange(onParametersUpdate);
                controls.add(parameters, 'radiusZ', 0, 10).onChange(onParametersUpdate);
                controls.add(parameters, 'size', 1, 400).onChange(onParametersUpdate);
                controls.add(parameters, 'scale', 1, 30).onChange(onParametersUpdate);
                controls.add(parameters, 'opacity', 0, 1).onChange(onParametersUpdate);
                controls.add(parameters, 'speedH', 0.1, 3).onChange(onParametersUpdate);
                controls.add(parameters, 'speedV', 0.1, 3).onChange(onParametersUpdate);
                controls.add(parameters, 'cameraX', -200, 200).onChange(onParametersUpdate);
                controls.add(parameters, 'cameraY', -200, 200).onChange(onParametersUpdate);
                controls.add(parameters, 'cameraZ', -200, 200).onChange(onParametersUpdate);

                //document.addEventListener('mousemove', function (e) {
                //    var mouseX = e.clientX,
                //        mouseY = e.clientY,
                //        width = window.innerWidth,
                //        halfWidth = width >> 1,
                //        height = window.innerHeight,
                //        halfHeight = height >> 1;

                //       cameraX = cameraRadius * (mouseX - halfWidth) / halfWidth;
                //       cameraY = cameraRadius * (mouseY - halfHeight) / halfHeight;
                //}, false);

                //document.addEventListener('mousewheel', onMouseWheel, false);
                //document.addEventListener('DOMMouseScroll', onMouseWheel, false);

            }

            function onMouseWheel(e) {
                e.preventDefault();

                if (e.wheelDelta) {
                    cameraZ += e.wheelDelta * 0.05;
                } else if (e.detail) {
                    cameraZ += e.detail * 0.5;
                }
            }

            function rand(v) {
                return (v * (Math.random() - 0.5));
            }

            var start = Date.now();
            //renders the scene
            function render() {

                shaderMaterial.uniforms['time'].value = .0051 * (Date.now() - start);
                shaderMaterial.uniforms['weight'].value = perWeight * (.5 + .5 * Math.sin(.0005 * (Date.now() - start)));


                renderer.render(scene, camera);

            }

            function animate() {

                requestAnimationFrame(animate);

                var delta = clock.getDelta(),
                    elapsedTime = clock.getElapsedTime();

                particleSystem.material.uniforms.elapsedTime.value = elapsedTime * 10;

                camera.position.set(cameraX, cameraY, cameraZ);
                camera.lookAt(cameraTarget);

                renderer.clear();
                render();
                renderer.render(scene, camera);

            }
        }

	</script>

	</body>
</html>
